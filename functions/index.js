// The Cloud Functions for Firebase SDK to create Cloud Functions and setup triggers
const functions = require("firebase-functions");

// Framework to supply methods for routing HTTP request, configuring middleware, etc.
// Express provides an API to create and manage HTTP routes, payloads, and sessions.
const express = require("express");
const app = express();

//The Firebase Admin SDK to access Cloud Firestore
const firebaseConfig = {
  apiKey: "",
  authDomain: "",
  databaseURL: "",
  projectId: "",
  storageBucket: "",
  messagingSenderId: "",
  appId: "",
  measurementId: "",
};

const admin = require("firebase-admin");
admin.initializeApp();

const firebase = require("firebase");
firebase.initializeApp(firebaseConfig);
const db = admin.firestore();

/*                                                                  NOTES                                                              */
//+ Express routing methods that will handle HTTP requests
// --> The application will execute a callback function when it receives an HTTP request with the matching route (ednpoint/path)
//      and HTTP method.
//+ POST vs GET
// --> POST requests have information embedded in the request package to alter some data in the server-side
// --> GET requests have unique URLs and should read and return data
//+ Must terminate request/response cycles with a response method (res.json(), res.render(), res.send(), etc.)

/*                                                               END OF NOTES                                                          */

//Authentication middleware that will check if a user has a valid JWT generated by Firebase after logging in.
const authenticateJWT = (request, response, next) => {
  //Retrieve "Authorization" header from the request object
  const authHeader = request.get("Authorization");
  const arr = authHeader.split(" "); //"Bearer jwt_token_here"

  if (authHeader && arr[0] === "Bearer") {
    const jwt = arr[1];
    //Verify the authenticity and integrity of the token using veifyIdToken(token)
    admin
      .auth()
      .verifyIdToken(jwt)
      .then((decodedToken) => {
        //Extract the uid of the decoded token to securely identify the currently signed-in user on the server
        let uid = decodedToken.uid;
        request.user = decodedToken;
        return db.collection("users").where("userID", "==", uid).limit(1).get();
      })
      .then((querySnapshot) => {
        request.user.handle = querySnapshot.docs[0].data().handle;
        return next();
      })
      .catch((error) => {
        return response.status(500).json({
          message: "Error in authMiddleware",
          error: error.code,
        });
      });
  }
};

//TODO: User Authentication methods
app.post("/sign-up", (request, response) => {
  const newUser = {
    email: request.body.email,
    password: request.body.password,
    confirmPassword: request.body.confirmPassword,
    handle: request.body.handle,
  };

  //Ensure that confirmPassword === password
  if (newUser.password !== newUser.confirmPassword) {
    return response.status(500).json({
      error: "Passwords do not match",
    });
  }

  //TODO: Ensure that email is valid

  //Check if the user handle has been taken already
  db.doc(`/users/${newUser.handle}`)
    .get()
    .then((documentSnapshot) => {
      if (documentSnapshot.exists) {
        return response.status(500).json({
          error: `${newUser.handle} already in use. Use another handle.`,
        });
      } else {
        //User handle has not been taken
        let UID;
        firebase
          .auth()
          .createUserWithEmailAndPassword(newUser.email, newUser.password)
          .then((userCredential) => {
            UID = userCredential.user.uid;
            return firebase.auth().currentUser.getIdToken();
          })
          .then((accessToken) => {
            //Add new user to the "users" collection
            delete newUser.confirmPassword;
            delete newUser.password;

            newUser.userSince = new Date().toISOString();
            newUser.userID = UID;

            db.doc(`/users/${newUser.handle}`).set(newUser);
            return response.status(200).json({
              token: accessToken,
            });
          })
          .catch((error) => {
            return response.status(500).json({
              error: "Unable to create user with email and password",
              code: error.code,
            });
          });
      }
    });
});

app.post("/login", (request, response) => {
  const logUser = {
    email: request.body.email,
    password: request.body.password,
  };
  //TODO: Check that the inputs are appropriate
  firebase
    .auth()
    .signInWithEmailAndPassword(logUser.email, logUser.password)
    .then((userCredential) => {
      return userCredential.user.getIdToken();
    })
    .then((accessToken) => {
      return response.status(200).json({
        message: `Signed in user with email ${logUser.email}`,
        token: accessToken,
      });
    })
    .catch((error) => {
      return response.status(500).json({
        error: error.code,
      });
    });
});

//User Actions
/*RETRIEVE THE COLLECTION OF A USER*/
app.get("/get-sets", authenticateJWT, (request, response) => {
  db.collection("owned")
    .where("handle", "==", request.user.handle)
    .get()
    .then((snapshot) => {
      let docs = [];
      snapshot.forEach((doc) => {
        docs.push({
          docID: doc.id,
          docData: doc.data(),
        });
      });
      return response.status(200).json(docs);
    })
    .catch((error) => console.error(error));
});

/*ADD A SET TO A USER'S OWNED COLLECTION*/
app.post("/add-set-to-owned", authenticateJWT, (request, response) => {
  //TODO: Connect to Firestore -> Add a document to the "owned" collection.

  const doc = {
    handle: request.user.handle,
    setID: request.body.setID,
  };

  //Add new document to "owned" collection, assigning it a document ID automatically
  db.collection("owned")
    .add(doc)
    .then((docReference) => {
      console.log(`Added document with name: ${docReference.id}`);
      return response
        .status(200)
        .send(`Added document with name: ${docReference.id}`);
    })
    .catch((error) => {
      return response.status(500).send(`${error.code}: POST /add-set failed`);
    });
});

/*Delete a set from a user's collection*/
app.post("/delete-owned-set/:docID", authenticateJWT, (request, response) => {
  //TODO: Supply the set to delete by embedding the document ID through the URL or in the request.body
  //TODO: Ensure that the document supplied in the URL exists before deleting?

  db.collection("owned")
    .doc(`${request.params.docID}`)
    .delete()
    .then((writeResult) => {
      return response
        .status(200)
        .send(`Deleted document with ID: ${request.params.docID}`);
    })
    .catch((error) => {
      return response.status(500).send(`POST /delete-owned-set FAILED`);
    });
});

/*Add a set to the "sets" collection*/
app.post("/add-set-to-sets", (request, response) => {
  //TODO: Add set to the "sets" collection
  let newSet = {
    image: request.body.image,
    name: request.body.name,
    pieceCount: request.body.pieceCount,
    price: request.body.price,
    theme: request.body.theme,
    yearReleased: request.body.yearReleased,
    numOfFigs: request.body.numOfFigs,
    setID: request.body.setID,
  };

  //Add new set to "sets" collection
  db.collection("sets")
    .doc(`${newSet.setID}`) //Creates || Updates a document with a specified ID (ensure that it is unique)
    .set(newSet)
    .then((writeResult) => {
      return response.status(200).send(`Added set with set ID ${newSet.setID}`);
    })
    .catch((error) => {
      return response.status(500).send(`POST /add-set-to-sets FAILED`);
    });
});

//Express Routing Methods all under one Cloud function
const api2 = functions.https.onRequest(app);

module.exports = {
  api2,
};
