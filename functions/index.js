// The Cloud Functions for Firebase SDK to create Cloud Functions and setup triggers
const functions = require("firebase-functions");

// Framework to supply methods for routing HTTP request, configuring middleware, etc.
// Express provides an API to create and manage HTTP routes, payloads, and sessions.
// Cors provides the ability to cricumvent the "same Origin Policy", which is a security mechanism that all web browsers use follow
const express = require("express");
const app = express();
const cors = require("cors");

//The Firebase Admin SDK to access Cloud Firestore

const firebaseConfig = {
  apiKey: "",
  authDomain: "",
  databaseURL: "",
  projectId: "",
  storageBucket: "",
  messagingSenderId: "",
  appId: "",
  measurementId: "",
};

const admin = require("firebase-admin");
admin.initializeApp();

const firebase = require("firebase");
const e = require("express");
const { user } = require("firebase-functions/lib/providers/auth");
firebase.initializeApp(firebaseConfig);

const db = admin.firestore();

//TODO: figure out a way to add images to the storage so that downloaded documents display their correct image
//var storage = firebase.storage();     //The root (i.e. the default bucket of this app)
var bucket = admin.storage().bucket();

/*                                                                  NOTES                                                              */
//+ Express routing methods that will handle HTTP requests
// --> The application will execute a callback function when it receives an HTTP request with the matching route (ednpoint/path)
//      and HTTP method.
//+ POST vs GET
// --> POST requests have information embedded in the request package to alter some data in the server-side
// --> GET requests have unique URLs and should read and return data
//+ Must terminate request/response cycles with a response method (res.json(), res.render(), res.send(), etc.)
//+ JWT - JSON Web Token is stored in local storage
// --> JWT is comprised of a header, payload, and signature and it comes in this format -> (xxxx.yyyy.zzzz)

/*                                                               END OF NOTES                                                          */

const validateForm = (form) => {
  if (form.email.length === 0) {
    return "Error: Email field is empty";
  }
  else if (form.password.length === 0) {
    return "Error: Password field is empty";
  }
  /*
    TODO: Add email verification. Maybe add a better password requirements system. Check if handle is appropriate.
  */
  else {
    return "NONE"
  }
}

//Authentication middleware that will check if a user has a valid JWT generated by Firebase after logging in or signing up
const authenticateJWT = (request, response, next) => {
  //Retrieve "Authorization" header from the request object
  const authHeader = request.get("Authorization");
  const arr = authHeader.split(" "); //"Bearer jwt_token_here"

  if (authHeader && arr[0] === "Bearer") {
    const jwt = arr[1];
    //Verify the authenticity and integrity of the token using veifyIdToken(token)
    admin
      .auth()
      .verifyIdToken(jwt)
      .then((decodedToken) => {
        //Extract the uid of the decoded token to securely identify the currently signed-in user on the server
        let uid = decodedToken.uid;
        request.user = decodedToken;
        return db.collection("users").where("userID", "==", uid).limit(1).get();
      })
      .then((querySnapshot) => {
        request.user.handle = querySnapshot.docs[0].data().handle;
        return next();
      })
      .catch((error) => {
        return response.status(500).json({
          message: "Error in authMiddleware",
          error: error.code,
        });
      });
  }
  else {
    return response.status(500).json({
      message: "Authorization header does not exist"
    });
  }
};

const generateKeys = (set) => {
    let keys = [];
    let s = set.setID.toString();
    keys.push(...set.name.toLowerCase().split(/-| /i));
    keys.push(...set.theme.toLowerCase().split(/-| /i));
    keys.push(s);

    return keys;
}

const generateSequences = (queryString) => {
  let grams = {};
  let biGrams = [];
  let triGrams = [];
  let quadGrams = [];
  let n_values = [2, 3, 4];
  let j;

  j = n_values[0] - 1;
  for (let i = 0; j < queryString.length; i++) {
    let s = "";
    for (let k = i; k <= j; k++) {
      s += queryString[k];
    }
    biGrams.push(s);
    j += 1;
  }

  j = n_values[1] - 1;
  for (let i = 0; j < queryString.length; i++) {
    let s = "";
    for (let k = i; k <= j; k++) {
      s += queryString[k];
    }
    triGrams.push(s);
    j += 1;
  }
  
  j = n_values[2] - 1;
  for (let i = 0; j < queryString.length; i++) {
    let s = "";
    for (let k = i; k <= j; k++) {
      s += queryString[k];
    }
    quadGrams.push(s);
    j += 1;
  }

  grams.second = biGrams;
  grams.third = triGrams;
  grams.fourth = quadGrams;

  return grams;
}

const generateGrams = (sequences) => {
  //Limit of 10 anagrams due to Cloud Firestore's query limitations for "array-contains-any" conditional
  //TODO: So
  let grams = [];
  let n = 0;
  let limit;

  //4-grams should be given highest weight. 4-grams closer to the beginning of the string should have a higher weigth than the rest 
  limit = 5;
  while (n < limit && n < sequences.fourth.length) {
    grams.push(sequences.fourth[n]);
    n++;
  }

  //3-grams have second-tier weight. Those closer to the beginning of the string should given the most priority
  limit = 3;
  n = 0;
  while (n < limit && n < sequences.third.length) {
    grams.push(sequences.third[n]);
    n++;
  }

  //2-grams have the least amount of weight. Only the first two letters of a string can give us some info.
  limit = 2;
  n = 0;
  while (n < limit && n < sequences.second.length) {
    grams.push(sequences.second[n]);
    n++;
  }

  return grams;
}

//Middleware to allow Cross Origin Resource Sharing
const corsOptions = {
  origin: "http://localhost:3000", //Configures the Access-Control-Allow-Origin CORS header
  methods: "GET,HEAD,PUT,PATCH,POST,DELETE", //Configures the Access-Control-Allow-Methods CORS header
  preflightContinue: false,
  optionsSuccessStatus: 204,
};

//app.use(cors(corsOptions)); 
app.use(cors()); 

//TODO: User Authentication methods
app.post("/sign-up", (request, response) => {
  const newUser = {
    email: request.body.email.trim(),
    image: "https://firebasestorage.googleapis.com/v0/b/my-lego-sets.appspot.com/o/no-img.png?alt=media",
    password: request.body.password.trim(),
    confirmPassword: request.body.confirmPassword.trim(),
    handle: request.body.handle.trim(),
  };

  //Ensure that confirmPassword === password
  if (newUser.password !== newUser.confirmPassword) {
    return response.status(500).json({
      error: "auth/passwords-do-not-match",
    });
  }

  let errMessage = validateForm(newUser);
  if (errMessage !== "NONE") {
    return response.status(500).json( {
      error : errMessage
    })
  }

  //Generate the anagrams for this new user (will be used for search)
  let sequences = generateSequences(newUser.handle.toLowerCase());
  let grams = generateGrams(sequences);
  newUser.grams = grams;

  //Check if the user handle has been taken already
  db.doc(`/users/${newUser.handle}`)
    .get()
    .then((documentSnapshot) => {
      if (documentSnapshot.exists) {
        return response.status(500).json({
          error: "auth/handle-already-taken" 
        });
      } else {
        //User handle has not been taken
        let UID;
        firebase
          .auth()
          .createUserWithEmailAndPassword(newUser.email, newUser.password)
          .then((userCredential) => {
            UID = userCredential.user.uid;
            return firebase.auth().currentUser.getIdToken();
          })
          .then((accessToken) => {
            //Add new user to the "users" collection
            delete newUser.confirmPassword;
            delete newUser.password;

            newUser.userSince = new Date().toISOString();
            newUser.userID = UID;

            db.doc(`/users/${newUser.handle}`).set(newUser);
            return response.status(200).json({
              token: accessToken,
            });
          })
          .catch((error) => {
            return response.status(500).json({
              error: error.code,
            });
          });
      }
    });
});

app.post("/login", (request, response) => {
  const logUser = {
    email: request.body.email.trim(),
    password: request.body.password.trim(),
  };

  //TODO: Check that the inputs are appropriate
  let errMessage = validateForm(logUser);
  if (errMessage !== "NONE") {
    return response.status(500).json( {
      error : errMessage
    })
  }
  
  firebase
    .auth()
    .signInWithEmailAndPassword(logUser.email, logUser.password)
    .then((userCredential) => {
      return userCredential.user.getIdToken();
    })
    .then((accessToken) => {
      return response.status(200).json({
        message: `Signed in user with email ${logUser.email}`,
        token: accessToken,
      });
    })
    .catch((error) => {
      return response.status(500).json({
        error: error.code,
      });
    });
});

//User Actions
app.get("/get-sets/:setID", (request, response) => {
  //TODO: Return a single set from the "sets" catalogue ; No need to ensure if the user is authenticated or not

  //Check that the set exists in the database
  db.collection("sets")
    .doc(`${request.params.setID}`)
    .get()
    .then((documentSnapshot) => {
      if (documentSnapshot.exists) {
        return response.status(200).json({
          doc: documentSnapshot.data(),
          docID: documentSnapshot.id,
        });
      } else {
        return response.status(500).json({
          message: "Set not found",
        });
      }
    })
    .catch((error) => {
      return response.status(500).json({
        error: error.code,
        message: `/get-sets/${request.params.setID} failed`,
      });
    });
});

//TODO: Make search more precise.
//If the user searches for "Kylo Ren Shuttle Star Wars" it should put kylo ren related sets first and then display 
//the rest of the star wars sets
app.get("/search-sets", (request, response) => {
  //Extract the search query from path and convert the entire string to lower case. Split the resulting string using "-" and SPACE.
  let queryList = request.query.q.toLowerCase().split(/-| /i);

  //The value for comparison (i.e. queryList in this case) has a limit of 10 values  
  if (queryList.length > 10) {
    //TODO: Return an error or reduce the size of queryList to respect Firebase's query constraints
    ;
  }

  db.collection("sets")
    .where("keys", "array-contains-any", queryList)
    .get()
    .then( (querySnapshot) => {
      let docs = [];
      if (!querySnapshot.empty) {
       querySnapshot.forEach((doc) => {
          docs.push(doc.data());
       });
      }

      return response.status(200).json(docs);
    })
    .catch( (error) => {
      return response.status(500).json({
        error : error.message,
        errorCode : error.code,
        message : "Error with /sets path"
      });
    })
});

app.get("/search-users", (request, response) => {
  let query = request.query.q.toLowerCase().replace(/\s/g, "");

  //Generate the the n-gram sequencing for the query
  let sequences = generateSequences(query);
  const grams = generateGrams(sequences);

  if (grams.length >= 1) {
    db.collection("users")
      .where("grams", "array-contains-any", grams)   // "array-contains-any" requires a non-empty ArrayValue
      .get()
      .then( (querySnapshot) => {
        let docs = [];
        if (!querySnapshot.empty) {
          querySnapshot.forEach( (doc) => {
            docs.push(doc.data());
          })
        }
        return response.status(200).json(docs);
      })
      .catch( (error) => {
        return response.status(500).json( {
          code : error.code,
          message : error.message
        });
      })
  }
  else {
    return response.status(200).json([]);
  }
});

app.post("/get-user", (request, response) => {
    //request.body.handle will be used to query the "users" collection of the database
    db.collection("users")
      .doc(request.body.handle)
      .get()
      .then( (documentSnapshot) => {
        if (documentSnapshot.exists) {
          return response.status(200).json(documentSnapshot.data());
        }

        return response.status(500).json({
          error : "User does not exist"
        });
      })
      .catch( (error) => {
        return response.status(500).json({
          error : error.message,
          errorCode : error.code
        });
      })
});

/* 
//Route that was used once to update the image property of all of the documents in the "sets" collection.
//This route added a generic LEGO logo to all of the sets.
app.get("/test-image", (request, response) => {
  //Route used to update the "image" property of all the sets in the collection

  db.collection("sets")
    .get()
    .then( (querySnapshot) => {
      querySnapshot.forEach( ( doc ) => {
        doc.ref.update( {image : "https://firebasestorage.googleapis.com/v0/b/my-lego-sets.appspot.com/o/lego_logo.jpg?alt=media"} );
      });

      return response.status(200).json({
        message : "Updated all of the documents"
      });
    })
    .catch( (error) => {
      return response.status(500).json( {
        errorCode : error.code,
        message : "Failed querying the collection"
      });
    })
});
*/

//Route that was used once to update the image property of all of the documents in the "sets" collection.
//This route added a generic LEGO logo to all of the sets.
/*
app.get("/test-image", (request, response) => {
  //Route used to update the "image" property of all the sets in the collection

  db.collection("users")
    .get()
    .then( (querySnapshot) => {
      querySnapshot.forEach( ( doc ) => {
        doc.ref.update( {image : "https://firebasestorage.googleapis.com/v0/b/my-lego-sets.appspot.com/o/no-img.png?alt=media"} );
      });

      return response.status(200).json({
        message : "Updated all of the documents"
      });
    })
    .catch( (error) => {
      return response.status(500).json( {
        errorCode : error.code,
        message : "Failed querying the collection"
      });
    })
});
*/


/*RETRIEVE THE COLLECTION OF AN ONLINE USER*/
app.post("/get-sets-of-user", (request, response) => {
  db.collection("owned")
    .where("handle", "==", request.body.handle)
    .get()
    .then( (querySnapshot) => {
      let docs = [];
      querySnapshot.forEach( (doc) => {
        docs.push({
          image : doc.data().image,
          name : doc.data().name,
          numOfFigs : doc.data().numOfFigs,
          pieceCount : doc.data().pieceCount,
          price : doc.data().price,
          theme : doc.data().theme,
          setID : doc.data().setID,
          yearReleased : doc.data().yearReleased
        });
      });
      return response.status(200).json(docs);

    })
    .catch( (error) => {
      return response.status(500).json({
        error : error.message,
        errorCode : error.code
      });
    })
});

/*RETRIEVE THE COLLECTION OF A USER (REQUIRES AUTHORIZATION HEADER)*/
app.get("/get-sets", authenticateJWT, (request, response) => {
  db.collection("owned")
    .where("handle", "==", request.user.handle)
    .get()
    .then((snapshot) => {
      let docs = [];
      snapshot.forEach((doc) => {
        docs.push({
          docID: doc.id,
          docData: doc.data(),
        });
      });
      return response.status(200).json(docs);
    })
    .catch((error) => console.error(error));
});

/*
//Route that was used only once to initially update all of the documents in the "sets" collection.
//Introduced the "keys" property to all of the documents. This "keys" property will be used for search.
app.post("/index-documents", (request, response) => {
  db.collection("sets")
    .get()
    .then( (querySnapshot) => {
      let counter = 0;
      if (!querySnapshot.empty) {
        querySnapshot.forEach( (doc) => {
          let keys = [];
          let s = doc.data().setID.toString();
          keys.push(...doc.data().name.toLowerCase().split(/-| /i));
          keys.push(...doc.data().theme.toLowerCase().split(/-| /i));
          keys.push(s);          

          db.collection("sets")
            .doc(doc.id)
            .update( { keys })
          
          counter += 1;
        });

        return response.status(200).json({
          message : `Udpated ${counter} documents successfully`
        });
      }
      else {
        return response.status(50).json( {
          message : "Collection '/sets' is empty"
        })
      }
    })
    .catch( (error) => {
      return response.status(500).json( {
        errorCode : error.code,
        errorMessage : error.message
      });
    })
});
*/

/* ROUTE THAT WILL BE USED ONCE TO UPDATE THE DOCUMENTS IN THE "USERS" COLLECTION
   EVERY DOCUMENT WILL BE UPDATED TO HAVE A PROPERTY CALLED GRAMS WHICH WILL BE AN ARRAY 
   THAT CONTAINS 4-GRAM, 3-GRAM, AND 2-GRAM SEQUENCES THAT WILL BE USED FOR SEARCH PURPOSES
*/
/*
app.post("/add-grams-to-users", (request, response) => {
  //In order to update a document we need its document ID

  let collectionRef = db.collection("users");
  collectionRef.get()
    .then( (querySnapshot) => {
      if (!querySnapshot.empty) {
        let counter = 0;
        querySnapshot.forEach( (doc) => {
          let userHandle = doc.data().handle.toLowerCase();
          let sequences = generateSequences(userHandle);
          let grams = generateGrams(sequences);
    
          collectionRef.doc(doc.id).update({grams})
          counter++;
        });
        
        return response.status(200).json({
          message : `Updated ${counter} documents successfully!`
        });
      }

      else {
        return response.status(200).json({
          message : "Collection 'users' is empty"
        });
      }
    })
    .catch( (error) => {
      return response.status(500).json({
        message : error.messsage,
        code : error.code
      });
    })
  
});
*/

/*
app.post("/user-owns-set", authenticateJWT, (request, response) => {
  //Check if the currently logged in user owns a sepcified set
  db.collection("owned")
    .where("setID", "==", request.body.setID)
    .where("handle", "==", request.user.handle)
    .get()
    .then((querySnapshot) => {
      let userOwns = querySnapshot.empty;
      return response.status(200).json({
        exists : userOwns
      });
    })
    .catch( (error) => {
      return response.status(500).json({
        message : error.message,
        code : error.code
      });
    })
});
*/

app.get("/user-owns-set", (request, response) => {
  let user = request.query.userHandle;
  let set = parseInt(request.query.setID, 10);

  db.collection("owned")
    .where("setID", "==", set)
    .where("handle", "==", user)
    .get()
    .then((querySnapshot) => {
      let userOwns = querySnapshot.empty;
      return response.status(200).json({
        exists : userOwns,
      });
    })
    .catch( (error) => {
      return response.status(500).json({
        message : error.message,
        code : error.code
      });
    })
});



/*ADD A SET TO A USER'S OWNED COLLECTION*/
app.post("/add-set-to-owned", authenticateJWT, (request, response) => {
  const dataToSend = {
    handle: request.user.handle,
    setID: request.body.setID,
    image : request.body.image,
    name : request.body.name,
    numOfFigs : request.body.numOfFigs,
    pieceCount : request.body.pieceCount,
    price : request.body.price,
    theme : request.body.theme,
    yearReleased : request.body.yearReleased
  };

  let docRef = db.collection("users").doc(`${dataToSend.handle}`);

  docRef.get()
    .then( (documentSnapshot) => {
      //Check if the user exists in the "users" collection
      if (documentSnapshot.exists) {
        let userCollection = documentSnapshot.data().collection;
        //Check if the user already owns the current set that they are trying to add to their collection
        if (!userCollection.includes(dataToSend.setID)) {
          userCollection.push(dataToSend.setID);
          docRef.update( {collection : userCollection } )
            .then( () => {
              //Add relationship between set and owner to the "owned" collection
              db.collection("owned")
                .add(dataToSend)
                .then( (documentReference) => {
                  return response.status(200).json({
                    message : `Added document with ref ID ${documentReference.id}`
                  });
                })
                .catch( (error) => {
                  return response.status(500).json({
                    error : `Unable to add set to "owned" collection`,
                    code : error.code 
                  });
                })
            })
            .catch( (error) => {
              return response.status(500).json({
                error : `Unable to update ${request.user.handle} 'user' document`,
                code : error.code 
              });
            })
        }
        else {
          return response.status(500).json( {
            error : `You already own ${dataToSend.setID}`
          });
        }
      }
      else {
        return response.status(500).json( {
          error : `User not found in the 'users' collection`
        });
      }
    })
    .catch( (error) => {
      return response.status(500).json( {
        handle: request.user.handle,
        error: "Unable to locate user document from server",
        code: error.code,
        message : error.message
      })
    })
});

/*Delete a set from a user's collection*/
app.post("/remove-owned-set", authenticateJWT, (request, response) => {
  let data = {
    setID : request.body.setID,
    handle : request.user.handle
  };

  let docRef = db.collection("users").doc(`${data.handle}`);
  docRef.get()
    .then( (documentSnapshot) => {
      //Check to see if the user exists in the "users" collection
      if (documentSnapshot.exists) {
        let userCollection = documentSnapshot.data().collection;
        if (userCollection.includes(data.setID)) {
          //Remove set from 'collection' field in user's document
          const index = userCollection.indexOf(data.setID);
          userCollection.splice(index, 1);
          docRef.update( { collection : userCollection })
            .then( () => {
              //Delete relationship between set and user from "owned" collection
              db.collection("owned")
                .where("handle", "==", data.handle)
                .where("setID", "==", data.setID)
                .limit(1)
                .get()
                .then( (querySnapshot) => {
                  if (!querySnapshot.empty) {
                    querySnapshot.forEach( (queryDocSnapshot) => {
                      queryDocSnapshot.ref.delete()
                        .then( () => {
                          return response.status(200).json({
                            message : "Succefully deleted document from 'owned' collection"
                          });
                        })
                        .catch( (error) => {
                          return response.status(500).json( {
                            code : error.code,
                            message : error.message,
                            error : `Unable to delete relationship from "owned" collection`
                          });
                        })
                    })
                  }
                  else {
                    return response.status(500).json( {
                      error : `No documents from "owned" collection matched query`
                    });
                  }
                })
                .catch( (error) => {
                  return response.status(500).json({
                    code : error.code,
                    message : error.message,
                    error : `Unable to query "owned" collection`
                  });
                })
            })
            .catch( (error) => {
              return response.status(500).json( {
                code : error.code,
                message : error.message,
                error : `Unable to update ${data.handle}'s document in the "users" collection`
              });
            })
        }
        else {
          return response.status(200).json( {
            error : `${data.setID} is not in user's collection`
          });
        }
      }
      else {
        return response.status(200).json( {
          error : `${data.handle} document does not exist in 'users' collection`
        });
      }
    })
    .catch( (error) => {
      return response.status(500).json( {
        code : error.code,
        message : error.message,
      });
    })
});

app.get("/authenticate-user/:jwt_token", (request, response) => {
  let idToken = request.params.jwt_token;
  admin
    .auth()
    .verifyIdToken(idToken)
    .then( (decodedToken) => {
      let uid = decodedToken.uid;
      db.collection("users")
        .where("userID", "==", uid)
        .limit(1)
        .get()
        .then( (querySnapshot) => {
          let userHandle = querySnapshot.docs[0].data().handle;
          let userCollection = querySnapshot.docs[0].data().collection;
          return response.status(200).json({
            handle : userHandle,
            collection : userCollection
          });
        })
        .catch( (error) => {
          return response.status(500).json({
            message : error.message,
            code : error.code
          });
        })

    })
    .catch( (error) => {
      return response.status(500).json({
        message : error.message,
        code : error.code
      });
    });
});

/*Add a set to the "sets" collection*/
app.post("/add-set-to-sets", (request, response) => {
  //TODO: Ensure that only the admin has the ability to change the "sets" collection
  //Create a reference with an intial file path and name

  /*
  var storage = firebase.storage();
  var pathReference = storage.ref('lego_logo.jpg');

  //Create a reference from a Google Cloud Storage URI
  var gsReference = storage.refFromURL()
  */

  let newSet = {
    image: request.body.image,
    name: request.body.name,
    pieceCount: request.body.pieceCount,
    price: request.body.price,
    theme: request.body.theme,
    yearReleased: request.body.yearReleased,
    numOfFigs: request.body.numOfFigs,
    setID: request.body.setID,
  };

  //Generate "keys" for set. "Keys" will be used to match sets with a user's search query 
  let keys = generateKeys(newSet);
  newSet.keys = keys;

  //Add new set to "sets" collection
  db.collection("sets")
    .doc(`${newSet.setID}`) //Creates || Updates a document with a specified ID (ensure that it is unique)
    .set(newSet)
    .then(() => {
      return response.status(200).send(`Added set with set ID ${newSet.setID}`);
    })
    .catch((error) => {
      return response.status(500).send(`POST /add-set-to-sets FAILED`);
    });
});

//Express Routing Methods all under one Cloud function
const api2 = functions.https.onRequest(app);

module.exports = {
  api2,
};