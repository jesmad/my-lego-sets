// The Cloud Functions for Firebase SDK to create Cloud Functions and setup triggers
const functions = require("firebase-functions");



// Framework to supply methods for routing HTTP request, configuring middleware, etc.
// Express provides an API to create and manage HTTP routes, payloads, and sessions.
// Cors provides the ability to cricumvent the "same Origin Policy", which is a security mechanism that all web browsers use follow
const express = require("express");
const app = express();
const cors = require("cors");

//The Firebase Admin SDK to access Cloud Firestore
const firebaseConfig = {
  apiKey: "",
  authDomain: "",
  databaseURL: "",
  projectId: "",
  storageBucket: "",
  messagingSenderId: "",
  appId: "",
  measurementId: "",
};

const admin = require("firebase-admin");
admin.initializeApp();

const firebase = require("firebase");
firebase.initializeApp(firebaseConfig);

const db = admin.firestore();


//TODO: figure out a way to add images to the storage so that downloaded documents display their correct image
//var storage = firebase.storage();     //The root (i.e. the default bucket of this app)
var bucket = admin.storage().bucket();

/*                                                                  NOTES                                                              */
//+ Express routing methods that will handle HTTP requests
// --> The application will execute a callback function when it receives an HTTP request with the matching route (ednpoint/path)
//      and HTTP method.
//+ POST vs GET
// --> POST requests have information embedded in the request package to alter some data in the server-side
// --> GET requests have unique URLs and should read and return data
//+ Must terminate request/response cycles with a response method (res.json(), res.render(), res.send(), etc.)

/*                                                               END OF NOTES                                                          */

const validateForm = (form) => {
  if (form.email.length === 0) {
    return "Error: Email field is empty";
  }
  else if (form.password.length === 0) {
    return "Error: Password field is empty";
  }
  /*
    TODO: Add email verification. Maybe add a better password requirements system. Check if handle is appropriate.
  */
  else {
    return "NONE"
  }
}

//Authentication middleware that will check if a user has a valid JWT generated by Firebase after logging in or signing up
const authenticateJWT = (request, response, next) => {
  //Retrieve "Authorization" header from the request object
  const authHeader = request.get("Authorization");
  const arr = authHeader.split(" "); //"Bearer jwt_token_here"

  if (authHeader && arr[0] === "Bearer") {
    const jwt = arr[1];
    //Verify the authenticity and integrity of the token using veifyIdToken(token)
    admin
      .auth()
      .verifyIdToken(jwt)
      .then((decodedToken) => {
        //Extract the uid of the decoded token to securely identify the currently signed-in user on the server
        let uid = decodedToken.uid;
        request.user = decodedToken;
        return db.collection("users").where("userID", "==", uid).limit(1).get();
      })
      .then((querySnapshot) => {
        request.user.handle = querySnapshot.docs[0].data().handle;
        return next();
      })
      .catch((error) => {
        return response.status(500).json({
          message: "Error in authMiddleware",
          error: error.code,
        });
      });
  }
};

const generateKeys = (set) => {
    let keys = [];
    let s = set.setID.toString();
    keys.push(...set.name.toLowerCase().split(/-| /i));
    keys.push(...set.theme.toLowerCase().split(/-| /i));
    keys.push(s);

    return keys;
}

const generateSequences = (queryString) => {
  let grams = {};
  let biGrams = [];
  let triGrams = [];
  let quadGrams = [];
  let n_values = [2, 3, 4];
  let j;

  j = n_values[0] - 1;
  for (let i = 0; j < queryString.length; i++) {
    let s = "";
    for (let k = i; k <= j; k++) {
      s += queryString[k];
    }
    biGrams.push(s);
    j += 1;
  }

  j = n_values[1] - 1;
  for (let i = 0; j < queryString.length; i++) {
    let s = "";
    for (let k = i; k <= j; k++) {
      s += queryString[k];
    }
    triGrams.push(s);
    j += 1;
  }
  
  j = n_values[2] - 1;
  for (let i = 0; j < queryString.length; i++) {
    let s = "";
    for (let k = i; k <= j; k++) {
      s += queryString[k];
    }
    quadGrams.push(s);
    j += 1;
  }

  grams.second = biGrams;
  grams.third = triGrams;
  grams.fourth = quadGrams;

  return grams;
}

const generateGrams = (sequences) => {
  //Limit of 10 anagrams due to Cloud Firestore's query limitations for "array-contains-any" conditional
  //TODO: So
  let grams = [];
  let n = 0;
  let limit;

  //4-grams should be given highest weight. 4-grams closer to the beginning of the string should have a higher weigth than the rest 
  limit = 5;
  while (n < limit && n < sequences.fourth.length) {
    grams.push(sequences.fourth[n]);
    n++;
  }

  //3-grams have second-tier weight. Those closer to the beginning of the string should given the most priority
  limit = 3;
  n = 0;
  while (n < limit && n < sequences.third.length) {
    grams.push(sequences.third[n]);
    n++;
  }

  //2-grams have the least amount of weight. Only the first two letters of a string can give us some info.
  limit = 2;
  n = 0;
  while (n < limit && n < sequences.second.length) {
    grams.push(sequences.second[n]);
    n++;
  }

  return grams;
}

//Middleware to allow Cross Origin Resource Sharing
const corsOptions = {
  origin: "http://localhost:3000", //Configures the Access-Control-Allow-Origin CORS header
  methods: "GET,HEAD,PUT,PATCH,POST,DELETE", //Configures the Access-Control-Allow-Methods CORS header
  preflightContinue: false,
  optionsSuccessStatus: 204,
};

app.use(cors(corsOptions)); //

//TODO: User Authentication methods
app.post("/sign-up", (request, response) => {
  const newUser = {
    email: request.body.email.trim(),
    image: "https://firebasestorage.googleapis.com/v0/b/my-lego-sets.appspot.com/o/no-img.png?alt=media",
    password: request.body.password.trim(),
    confirmPassword: request.body.confirmPassword.trim(),
    handle: request.body.handle.trim(),
  };

  //Ensure that confirmPassword === password
  if (newUser.password !== newUser.confirmPassword) {
    return response.status(500).json({
      error: "auth/passwords-do-not-match",
    });
  }

  let errMessage = validateForm(newUser);
  if (errMessage !== "NONE") {
    return response.status(500).json( {
      error : errMessage
    })
  }

  //Generate the anagrams for this new user (will be used for search)
  let sequences = generateSequences(newUser.handle.toLowerCase());
  let grams = generateGrams(sequences);
  newUser.grams = grams;

  //Check if the user handle has been taken already
  db.doc(`/users/${newUser.handle}`)
    .get()
    .then((documentSnapshot) => {
      if (documentSnapshot.exists) {
        return response.status(500).json({
          error: "auth/handle-already-taken" 
        });
      } else {
        //User handle has not been taken
        let UID;
        firebase
          .auth()
          .createUserWithEmailAndPassword(newUser.email, newUser.password)
          .then((userCredential) => {
            UID = userCredential.user.uid;
            return firebase.auth().currentUser.getIdToken();
          })
          .then((accessToken) => {
            //Add new user to the "users" collection
            delete newUser.confirmPassword;
            delete newUser.password;

            newUser.userSince = new Date().toISOString();
            newUser.userID = UID;

            db.doc(`/users/${newUser.handle}`).set(newUser);
            return response.status(200).json({
              token: accessToken,
            });
          })
          .catch((error) => {
            return response.status(500).json({
              error: error.code,
            });
          });
      }
    });
});

app.post("/login", (request, response) => {
  const logUser = {
    email: request.body.email.trim(),
    password: request.body.password.trim(),
  };

  //TODO: Check that the inputs are appropriate
  let errMessage = validateForm(logUser);
  if (errMessage !== "NONE") {
    return response.status(500).json( {
      error : errMessage
    })
  }
  
  firebase
    .auth()
    .signInWithEmailAndPassword(logUser.email, logUser.password)
    .then((userCredential) => {
      return userCredential.user.getIdToken();
    })
    .then((accessToken) => {
      return response.status(200).json({
        message: `Signed in user with email ${logUser.email}`,
        token: accessToken,
      });
    })
    .catch((error) => {
      return response.status(500).json({
        error: error.code,
      });
    });
});

//User Actions
app.get("/get-sets/:setID", (request, response) => {
  //TODO: Return a single set from the "sets" catalogue ; No need to ensure if the user is authenticated or not

  //Check that the set exists in the database
  db.collection("sets")
    .doc(`${request.params.setID}`)
    .get()
    .then((documentSnapshot) => {
      if (documentSnapshot.exists) {
        return response.status(200).json({
          doc: documentSnapshot.data(),
          docID: documentSnapshot.id,
        });
      } else {
        return response.status(500).json({
          message: "Set not found",
        });
      }
    })
    .catch((error) => {
      return response.status(500).json({
        error: error.code,
        message: `/get-sets/${request.params.setID} failed`,
      });
    });
});

//TODO: Make search more precise.
//If the user searches for "Kylo Ren Shuttle Star Wars" it should put kylo ren related sets first and then display 
//the rest of the star wars sets
app.get("/search-sets", (request, response) => {
  //Extract the search query from path and convert the entire string to lower case. Split the resulting string using "-" and SPACE.
  let queryList = request.query.q.toLowerCase().split(/-| /i);

  //The value for comparison (i.e. queryList in this case) has a limit of 10 values  
  if (queryList.length > 10) {
    //TODO: Return an error or reduce the size of queryList to respect Firebase's query constraints
    ;
  }

  db.collection("sets")
    .where("keys", "array-contains-any", queryList)
    .get()
    .then( (querySnapshot) => {
      let docs = [];
      if (!querySnapshot.empty) {
       querySnapshot.forEach((doc) => {
          docs.push(doc.data());
       });
      }

      return response.status(200).json(docs);
    })
    .catch( (error) => {
      return response.status(500).json({
        error : error.message,
        errorCode : error.code,
        message : "Error with /sets path"
      });
    })
});

app.get("/search-users", (request, response) => {
  let query = request.query.q.toLowerCase().replace(/\s/g, "");

  //Generate the the n-gram sequencing for the query
  let sequences = generateSequences(query);
  const grams = generateGrams(sequences);

  db.collection("users")
    .where("grams", "array-contains-any", grams)
    .get()
    .then( (querySnapshot) => {
      let docs = [];
      if (!querySnapshot.empty) {
        querySnapshot.forEach( (doc) => {
          docs.push(doc.data());
        })
      }
      return response.status(200).json(docs);
    })
    .catch( (error) => {
      return response.status(500).json( {
        code : error.code,
        message : error.message
      });
    })
});

/* 
//Route that was used once to update the image property of all of the documents in the "sets" collection.
//This route added a generic LEGO logo to all of the sets.
app.get("/test-image", (request, response) => {
  //Route used to update the "image" property of all the sets in the collection

  db.collection("sets")
    .get()
    .then( (querySnapshot) => {
      querySnapshot.forEach( ( doc ) => {
        doc.ref.update( {image : "https://firebasestorage.googleapis.com/v0/b/my-lego-sets.appspot.com/o/lego_logo.jpg?alt=media"} );
      });

      return response.status(200).json({
        message : "Updated all of the documents"
      });
    })
    .catch( (error) => {
      return response.status(500).json( {
        errorCode : error.code,
        message : "Failed querying the collection"
      });
    })
});
*/

//Route that was used once to update the image property of all of the documents in the "sets" collection.
//This route added a generic LEGO logo to all of the sets.
/*
app.get("/test-image", (request, response) => {
  //Route used to update the "image" property of all the sets in the collection

  db.collection("users")
    .get()
    .then( (querySnapshot) => {
      querySnapshot.forEach( ( doc ) => {
        doc.ref.update( {image : "https://firebasestorage.googleapis.com/v0/b/my-lego-sets.appspot.com/o/no-img.png?alt=media"} );
      });

      return response.status(200).json({
        message : "Updated all of the documents"
      });
    })
    .catch( (error) => {
      return response.status(500).json( {
        errorCode : error.code,
        message : "Failed querying the collection"
      });
    })
});
*/

/*RETRIEVE THE COLLECTION OF A USER*/
app.get("/get-sets", authenticateJWT, (request, response) => {
  db.collection("owned")
    .where("handle", "==", request.user.handle)
    .get()
    .then((snapshot) => {
      let docs = [];
      snapshot.forEach((doc) => {
        docs.push({
          docID: doc.id,
          docData: doc.data(),
        });
      });
      return response.status(200).json(docs);
    })
    .catch((error) => console.error(error));
});

/*
//Route that was used only once to initially update all of the documents in the "sets" collection.
//Introduced the "keys" property to all of the documents. This "keys" property will be used for search.
app.post("/index-documents", (request, response) => {
  db.collection("sets")
    .get()
    .then( (querySnapshot) => {
      let counter = 0;
      if (!querySnapshot.empty) {
        querySnapshot.forEach( (doc) => {
          let keys = [];
          let s = doc.data().setID.toString();
          keys.push(...doc.data().name.toLowerCase().split(/-| /i));
          keys.push(...doc.data().theme.toLowerCase().split(/-| /i));
          keys.push(s);          

          db.collection("sets")
            .doc(doc.id)
            .update( { keys })
          
          counter += 1;
        });

        return response.status(200).json({
          message : `Udpated ${counter} documents successfully`
        });
      }
      else {
        return response.status(50).json( {
          message : "Collection '/sets' is empty"
        })
      }
    })
    .catch( (error) => {
      return response.status(500).json( {
        errorCode : error.code,
        errorMessage : error.message
      });
    })
});
*/

/* ROUTE THAT WILL BE USED ONCE TO UPDATE THE DOCUMENTS IN THE "USERS" COLLECTION
   EVERY DOCUMENT WILL BE UPDATED TO HAVE A PROPERTY CALLED GRAMS WHICH WILL BE AN ARRAY 
   THAT CONTAINS 4-GRAM, 3-GRAM, AND 2-GRAM SEQUENCES THAT WILL BE USED FOR SEARCH PURPOSES
*/
/*
app.post("/add-grams-to-users", (request, response) => {
  //In order to update a document we need its document ID

  let collectionRef = db.collection("users");
  collectionRef.get()
    .then( (querySnapshot) => {
      if (!querySnapshot.empty) {
        let counter = 0;
        querySnapshot.forEach( (doc) => {
          let userHandle = doc.data().handle.toLowerCase();
          let sequences = generateSequences(userHandle);
          let grams = generateGrams(sequences);
    
          collectionRef.doc(doc.id).update({grams})
          counter++;
        });
        
        return response.status(200).json({
          message : `Updated ${counter} documents successfully!`
        });
      }

      else {
        return response.status(200).json({
          message : "Collection 'users' is empty"
        });
      }
    })
    .catch( (error) => {
      return response.status(500).json({
        message : error.messsage,
        code : error.code
      });
    })
  
});
*/
/*ADD A SET TO A USER'S OWNED COLLECTION*/
app.post("/add-set-to-owned", authenticateJWT, (request, response) => {
  //TODO: Connect to Firestore -> Add a document to the "owned" collection.

  const doc = {
    handle: request.user.handle,
    setID: request.body.setID,
  };

  //Check if the user already has this set in their collection
  db.collection("owned")
    .where("setID", "==", doc.setID)
    .where("handle", "==", doc.handle)
    .get()
    .then((querySnapshot) => {
      if (!querySnapshot.empty) {
        return response.json({
          message: `You already own ${doc.setID}`,
        });
      } else {
        //Add set to user collection
        db.collection("owned")
          .add(doc)
          .get()
          .then((docReference) => {
            return response
              .status(200)
              .send(`Added document with name: ${docReference.id}`);
          });
      }
    })
    .catch((error) => {
      return response.status(500).json({
        error: error.code,
        errorMessage: "/add-set-to-owned FAILED",
      });
    });
});

/*Delete a set from a user's collection*/
app.post("/delete-owned-set/:docID", authenticateJWT, (request, response) => {
  //TODO: Supply the set to delete by embedding the document ID through the URL or in the request.body
  //TODO: Ensure that the document supplied in the URL exists before deleting?
  let docReference = db.collection("owned").doc(`${request.params.docID}`);
  docReference
    .get()
    .then((documentSnapshot) => {
      if (documentSnapshot.exists) {
        //Ensure that the document has the same owner
        let docHandle = documentSnapshot.get("handle");
        if (docHandle === `${request.user.handle}`) {
          docReference.delete().then(() => {
            return response.status(200).json({
              message: `Document with ID ${request.params.docID} successfully deleted.`,
            });
          });
        } else {
          return response.status(200).json({});
        }
      } else {
        return response.status(200).json({
          message: "DOCUMENT DOES NOT EXIST",
        });
      }
    })
    .catch((error) => {
      return response.status(500).json({
        message: `/delete-owned-set/${request.params.docID} FAILED`,
      });
    });
});

/*Add a set to the "sets" collection*/
app.post("/add-set-to-sets", (request, response) => {
  //TODO: Ensure that only the admin has the ability to change the "sets" collection
  //Create a reference with an intial file path and name

  /*
  var storage = firebase.storage();
  var pathReference = storage.ref('lego_logo.jpg');

  //Create a reference from a Google Cloud Storage URI
  var gsReference = storage.refFromURL()
  */

  let newSet = {
    image: request.body.image,
    name: request.body.name,
    pieceCount: request.body.pieceCount,
    price: request.body.price,
    theme: request.body.theme,
    yearReleased: request.body.yearReleased,
    numOfFigs: request.body.numOfFigs,
    setID: request.body.setID,
  };

  //Generate "keys" for set. "Keys" will be used to match sets with a user's search query 
  let keys = generateKeys(newSet);
  newSet.keys = keys;

  //Add new set to "sets" collection
  db.collection("sets")
    .doc(`${newSet.setID}`) //Creates || Updates a document with a specified ID (ensure that it is unique)
    .set(newSet)
    .then(() => {
      return response.status(200).send(`Added set with set ID ${newSet.setID}`);
    })
    .catch((error) => {
      return response.status(500).send(`POST /add-set-to-sets FAILED`);
    });
});

//Express Routing Methods all under one Cloud function
const api2 = functions.https.onRequest(app);

module.exports = {
  api2,
};
